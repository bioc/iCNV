
# iCNV Vignette

## Author
Zilu Zhou, Nancy R. Zhang

## Maintainer
Zilu Zhou <zhouzilu@upenn.edu>

## Date
09/06/2017

  This is a demo for using the **iCNV** package in R. **iCNV** is a normalization and copy number variation detection procedure for mutiple study designs: WES only, WGS only, SNP array only, or any combination of SNP and sequencing data. **iCNV** applies platform specific normalization, utilizes allele specific reads from sequencing and integrates matched NGS and SNP-array data by a Hidden Markov Model (HMM). Figure 1 shows the overall pipeline. This package specifically emphasizes on the steps within the red box. Below is an example on calling copy number variation using whole-exome sequencing data and array SNPs of 38 samples from Alzheimer's Disease Sequencing Project. Only second half of chromesome 22 are analysed for illustration purposes. We will seperately shows normalization for WES and SNP array. We will also introduce integrated calling procedure as well as single platform procedure. R packages are avaliable at github and the toy dataset.


## 1. Website and online forum

iCNV's website with usage and installation information: https://github.com/zhouzilu/iCNV 

## 2. iCNV workflow
We could seperate the basic iCNV workflow into 5 steps: **1.** package installation; **2.** .bam file normalization; **3.** sequence variants BAF calling; **4.** SNP array LRR normalization and BAF; **5.** CNV detection using `iCNV_detection` function. We will illustrate them one by one in the following sessions.

### 2.1 Install iCNV.

Install iCNV dependent packages `fields, truncnorm, ggplot2, and CODEX` first
```r
install.packages("fields")
install.packages("truncnorm")
install.packages("ggplot2")
## try http:// if https:// URLs are not supported
source("https://bioconductor.org/biocLite.R")
biocLite("CODEX")
```
Install the current release from Github:
```r
install.packages("devtools")
library(devtools)
install_github("zhouzilu/iCNV")
```
### 2.2 .bam file normalization using CODEX
```r
###################################################
### 2.2 code chunk number 1: bambedObj1
###################################################
library(CODEX)
dirPath <- 'PATH/TO/BAM/'
setwd(dirPath)
bamFile <- list.files(dirPath, pattern = '*.bam$')
bamdir <- file.path(dirPath, bamFile)
sampname <- as.matrix(read.table(file.path(dirPath, "sampname")))
bedFile <- file.path(dirPath, "chr22_400_to_500.bed")
chr <- 22
bambedObj <- getbambed(bamdir = bamdir, bedFile = bedFile, 
                   sampname = sampname, projectname = "UPENN_UPENN_sample", chr)
bamdir <- bambedObj$bamdir; sampname <- bambedObj$sampname
ref <- bambedObj$ref; projectname <- bambedObj$projectname; chr <- bambedObj$chr
###################################################
### 2.2 code chunk number 2: coverageObj1
###################################################
coverageObj <- getcoverage(bambedObj, mapqthres = 20)
Y <- coverageObj$Y; readlength <- coverageObj$readlength
###################################################
### 2.2 code chunk number 3: gcmapp1
###################################################
gc <- getgc(chr, ref)
mapp <- getmapp(chr, ref)
###################################################
### 2.2 code chunk number 4: qcObj1
###################################################
qcObj <- qc(Y, sampname, chr, ref, mapp, gc, cov_thresh = c(20, 4000), 
            length_thresh = c(20, 2000), mapp_thresh = 0.9, gc_thresh = c(20, 80))
Y_qc <- qcObj$Y_qc; sampname_qc <- qcObj$sampname_qc; gc_qc <- qcObj$gc_qc
mapp_qc <- qcObj$mapp_qc; ref_qc <- qcObj$ref_qc; qcmat <- qcObj$qcmat
###################################################
### 2.2 code chunk number 5: normObj1
###################################################
normObj <- normalize(Y_qc, gc_qc, K = 1:7)
Yhat <- normObj$Yhat; AIC <- normObj$AIC; BIC <- normObj$BIC
RSS <- normObj$RSS; K <- normObj$K
choiceofK(AIC, BIC, RSS, K, filename = paste("projectname, "_", chr, 
                                             "_choiceofK", ".pdf", sep = ""))
save(qcObj,normObj,sampname,file=paste0(projectname,"_",chr,".rda") )
```
CODEX reports all three statistical metrics (AIC, BIC, percent of Variance explained) and uses BIC as the
default method to determine the number of Poisson factors. Since false positives can be screened out through
a closer examination of the post-segmentation data, whereas CNV signals removed in the normalization step
cannot be recovered, CODEX opts for a more conservative normalization that, when in doubt, uses a smaller
value of K.
```r
optK = K[which.max(BIC)]
load(paste0(projectname,"_",chr,".rda"))
###################################################
### 2.2 code chunk number 6: plr
###################################################
Y_qc <- qcObj$Y_qc; sampname_qc <- qcObj$sampname_qc; gc_qc <- qcObj$gc_qc
mapp_qc <- qcObj$mapp_qc; ref_qc <- qcObj$ref_qc; qcmat <- qcObj$qcmat
Yhat <- normObj$Yhat; AIC <- normObj$AIC; BIC <- normObj$BIC
RSS <- normObj$RSS; K <- normObj$K
ref_qc=qcObj$ref_qc # IRanges object for exon target
sampname_qc=qcObj$sampname_qc # sample names
Y_norm=normObj$Yhat[[optK]] # normalized read count under null (no CNV)
plr=log(pmax(Y_qc,0.0001)/pmax(Y_norm,0.0001)) # log transformed z-scores
plrObj=list(ref_qc,sampname,sampname_qc,Y_norm,Y_qc,plr)
save(plrObj,file=paste0(projectname,'plrObj',chr,'_',optK,'.rda'))
```
For detailed illustration of CODEX, please check https://github.com/yuchaojiang/CODEX

### 2.3 sequence variants BAF calling

For sequencing data without sophisticated pipeline and SNVs call set in VCF format, we manually call SNVs from quality controlled BAM files by mpileup module in samtools, and calculate B allele frequency(BAF) on heterogeneous loci by dividing DV (Number of high-quality non-reference bases, FORMAT) from DP (Number of high-quality bases, FORMAT). Example code are:
```
# Prerequest: samtools, bcftools and reference fasta file
cd PATH/TO/BAM
for i in *bam; do PATH/TO/SAMTOOLS/samtools mpileup -ugI -t DP -t DV -f PATH/TO/REF/human_hg37.fasta $i | ~/bcftools-1.3.1/bcftools call -cv -O z -o PATH/TO/OUTPUT/$i.vcf.gz; done

```

### 2.4 SNP array LRR normalization and BAF

For some of the SNP array LRR data, we need to apply SVD normalization to remove high dimension noisy and preserve low dimension signal. The best way to decide data senity is by plotting out the data. Noisy data has the feature of local strip across samples. Example code for remove high dimension noisy:
```r
# lrr is LRR matrix, with row as sample and column as positions
# You may want to substitute all the NAs in lrr by rowMeans
lrr.svd = svd (lrr)
pdf(paste0(projectname,'_SVD.pdf'),height=10,width=14)
for (K in 0:9){
	D=diag(lrr.svd$d)
	D.lowrank=diag(c(rep(0,K),lrr.svd$d[-(seq(1,K,1))]))
	lowrank=t(lrr.svd$u %*% D.lowrank %*% t(lrr.svd$v))
	toplot=apply(lowrank,2,function(x){(x-mean(x,na.rm=T))/sd(x,na.rm=T)})
	l=3
	image.plot(x=seq(1,nrow(toplot)),y=seq(1,ncol(toplot)),z=pmin(pmax(toplot,-l),l),
	  xlab=paste0('chr',chr),ylab='samples',main=paste0('K=',K)
}
dev.off()

```

### 2.5 CNV detection using **iCNV**

At this step, we should alreday have PLR and variants BAF from sequencing, normalized LRR and BAF from SNP array.
```r
library(iCNV)
str(z1) # List of n vector, each one is the PLR for an exon
str(z1pos) # List of n matrix (p x 2), each one is the start and end location for an exon
str(baf1) # List of n vector, each one is the variants BAF from .bam
str(baf1pos) # List of n vector, each one is the variants BAF position
str(z2) # List of n vector, each one is the normalized LRR for a SNP
str(z2pos) # List of n vector, each one is a SNP position
str(baf2) # List of n vector, each one is the BAF for a SNP
str(baf2pos) # List of n vector, each one is the SNP BAF position
finalcall <- iCNV_detection(z1,z2,baf1,baf2,z1pos,z2pos,baf1pos,baf2pos,mu=c(-3,0,2),projname=projname)
```

