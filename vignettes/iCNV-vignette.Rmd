
# iCNV Vignette

## Author
Zilu Zhou, Nancy R. Zhang

## Maintainer
Zilu Zhou <zhouzilu@pennmedicine.upenn.edu>

## Date
09/27/2017

  This is a demo for using the **iCNV** package in R. **iCNV** is a normalization and copy number variation detection procedure for mutiple study designs: WES only, WGS only, SNP array only, or any combination of SNP and sequencing data. **iCNV** applies platform specific normalization, utilizes allele specific reads from sequencing and integrates matched NGS and SNP-array data by a Hidden Markov Model (HMM). Figure 1 shows the overall pipeline. This package specifically emphasizes on the steps within the red box. Below is an example on calling copy number variation using whole-exome sequencing data and array SNPs of 38 samples from Alzheimer's Disease Sequencing Project. Only second half of chromesome 22 are analysed for illustration purposes. We will seperately shows normalization for WES and SNP array. We will also introduce integrated calling procedure as well as single platform procedure. R packages are avaliable at github as well as the toy dataset.

  We strongly recommend to combine platform when both WES data and SNP array are available. However, for high quality  WGS data, SNP information isn't so necessary.

## 1. Website and online forum

iCNV's website with usage and installation information: https://github.com/zhouzilu/iCNV 

## 2. iCNV workflow
We could seperate the basic iCNV workflow into 5 steps: **1.** package installation; **2.** .bam file normalization; **3.** sequence variants BAF calling; **4.** SNP array LRR normalization and BAF; **5.** CNV detection using `iCNV_detection` function. **6.** CNV detection using `iCNV_detection` function with single platform. We will illustrate them one by one in the following sessions.

### 2.1 Install iCNV.

Install iCNV dependent packages `fields, truncnorm, ggplot2, and CODEX` first
```r
install.packages("fields")
install.packages("truncnorm")
install.packages("ggplot2")
## try http:// if https:// URLs are not supported
source("https://bioconductor.org/biocLite.R")
biocLite("CODEX")
```
Install the current release from Github:
```r
install.packages("devtools")
library(devtools)
install_github("zhouzilu/iCNV")
```
### 2.2 .bam file normalization using CODEX
```r
###################################################
### 2.2 code chunk number 1: bambedObj1
###################################################
library(CODEX)
dirPath <- 'PATH/TO/BAM/'
setwd(dirPath)
bamFile <- list.files(dirPath, pattern = '*.bam$')
bamdir <- file.path(dirPath, bamFile)
sampname <- as.matrix(read.table(file.path(dirPath, "sampname")))
bedFile <- file.path(dirPath, "chr22_400_to_500.bed")
chr <- 22
bambedObj <- getbambed(bamdir = bamdir, bedFile = bedFile, 
                   sampname = sampname, projectname = "UPENN_UPENN_sample", chr)
bamdir <- bambedObj$bamdir; sampname <- bambedObj$sampname
ref <- bambedObj$ref; projectname <- bambedObj$projectname; chr <- bambedObj$chr
###################################################
### 2.2 code chunk number 2: coverageObj1
###################################################
coverageObj <- getcoverage(bambedObj, mapqthres = 20)
Y <- coverageObj$Y; readlength <- coverageObj$readlength
###################################################
### 2.2 code chunk number 3: gcmapp1
###################################################
gc <- getgc(chr, ref)
mapp <- getmapp(chr, ref)
###################################################
### 2.2 code chunk number 4: qcObj1
###################################################
qcObj <- qc(Y, sampname, chr, ref, mapp, gc, cov_thresh = c(20, 4000), 
            length_thresh = c(20, 2000), mapp_thresh = 0.9, gc_thresh = c(20, 80))
Y_qc <- qcObj$Y_qc; sampname_qc <- qcObj$sampname_qc; gc_qc <- qcObj$gc_qc
mapp_qc <- qcObj$mapp_qc; ref_qc <- qcObj$ref_qc; qcmat <- qcObj$qcmat
###################################################
### 2.2 code chunk number 5: normObj1
###################################################
normObj <- normalize(Y_qc, gc_qc, K = 1:7)
Yhat <- normObj$Yhat; AIC <- normObj$AIC; BIC <- normObj$BIC
RSS <- normObj$RSS; K <- normObj$K
choiceofK(AIC, BIC, RSS, K, filename = paste("projectname, "_", chr, 
                                             "_choiceofK", ".pdf", sep = ""))
save(qcObj,normObj,sampname,file=paste0(projectname,"_",chr,".rda") )
```
CODEX reports all three statistical metrics (AIC, BIC, percent of Variance explained) and uses BIC as the
default method to determine the number of Poisson factors. Since false positives can be screened out through
a closer examination of the post-segmentation data, whereas CNV signals removed in the normalization step
cannot be recovered, CODEX opts for a more conservative normalization that, when in doubt, uses a smaller
value of K.
```r
optK = K[which.max(BIC)]
load(paste0(projectname,"_",chr,".rda"))
###################################################
### 2.2 code chunk number 6: plr
###################################################
Y_qc <- qcObj$Y_qc; sampname_qc <- qcObj$sampname_qc; gc_qc <- qcObj$gc_qc
mapp_qc <- qcObj$mapp_qc; ref_qc <- qcObj$ref_qc; qcmat <- qcObj$qcmat
Yhat <- normObj$Yhat; AIC <- normObj$AIC; BIC <- normObj$BIC
RSS <- normObj$RSS; K <- normObj$K
ref_qc=qcObj$ref_qc # IRanges object for exon target
sampname_qc=qcObj$sampname_qc # sample names
Y_norm=normObj$Yhat[[optK]] # normalized read count under null (no CNV)
plr=log(pmax(Y_qc,0.0001)/pmax(Y_norm,0.0001)) # log transformed z-scores
ngs_plr=lapply(seq_len(ncol(plr)), function(i) plr[,i])
ngs_plr.pos=lapply(seq(1,length(ngs_plr)),function(x){cbind(start(ref_qc),end(ref_qc))})
save(ref_qc,sampname_qc,Y_norm,Y_qc,ngs_plr,ngs_plr.pos,file=paste0(projectname,'_plrObj_',chr,'_',optK,'.rda'))
```
For detailed illustration of CODEX, please check https://github.com/yuchaojiang/CODEX

### 2.3 sequence variants BAF calling

For sequencing data without sophisticated pipeline and SNVs call set in VCF format, we manually call SNVs from quality controlled BAM files by mpileup module in samtools, and calculate B allele frequency(BAF) on heterogeneous loci by dividing DV (Number of high-quality non-reference bases, FORMAT) from DP (Number of high-quality bases, FORMAT). Example code are:
```
# Prerequest: samtools, bcftools and reference fasta file
cd PATH/TO/BAM
for i in *bam; do PATH/TO/SAMTOOLS/samtools mpileup -ugI -t DP -t DV -f PATH/TO/REF/human_hg37.fasta $i | ~/bcftools-1.3.1/bcftools call -cv -O z -o PATH/TO/OUTPUT/$i.vcf.gz; done
```

### 2.4 SNP array LRR normalization and BAF

For some of the SNP array LRR data, we need to apply SVD normalization to remove high dimension noisy and preserve low dimension signal. The best way to decide data senity is by plotting out the data. Noisy data has the feature of local strip across samples. Conventional way for identifying elbow points can also apply here. Example code for remove high dimension noisy and plot:
```r
# lrr is LRR matrix, with row as sample and column as positions
# You may want to substitute all the NAs in lrr by rowMeans
lrr.svd = svd (lrr)
pdf(paste0(projectname,'_SVD.pdf'),height=10,width=14)
plot(x=seq(0,9),y=diag(lrr.svd$d),xlab='K,',ylab='D',main='')
for (K in 0:9){
	D=diag(lrr.svd$d)
	D.lowrank=diag(c(rep(0,K),lrr.svd$d[-(seq(1,K,1))]))
	lowrank=t(lrr.svd$u %*% D.lowrank %*% t(lrr.svd$v))
	toplot=apply(lowrank,2,function(x){(x-mean(x,na.rm=T))/sd(x,na.rm=T)})
	l=3
	image.plot(x=seq(1,nrow(toplot)),y=seq(1,ncol(toplot)),z=pmin(pmax(toplot,-l),l),
	  xlab=paste0('chr',chr),ylab='samples',main=paste0('K=',K)
}
dev.off()
```

### 2.5 Mutiple platform CNV detection using **iCNV**

At this step, we should alreday have PLR and variants BAF from sequencing, normalized LRR and BAF from SNP array. Please make sure all the input are in list form. This is mainly to accomadate the fact that length for `ngs_baf` and `ngs_baf.pos` is sample specific
Try out with the Demo code and sample dataset in https://github.com/zhouzilu/iCNV/tree/master/demo
```r
library(iCNV)
load('demo_data.rda')
ls()
str(ngs_plr) # List of n vector, each one is the PLR for an exon
str(ngs_plr.pos) # List of n matrix (p x 2), each one is the start and end location for an exon
str(ngs_baf) # List of n vector, each one is the variants BAF from .bam
str(ngs_baf.pos) # List of n vector, each one is the variants BAF position
str(snp_lrr) # List of n vector, each one is the normalized LRR for a SNP
str(snp_lrr.pos) # List of n vector, each one is a SNP position
str(snp_baf) # List of n vector, each one is the BAF for a SNP
str(snp_baf.pos) # List of n vector, each one is the SNP BAF position
projname='icnv.demo'
icnv_res0=iCNV_detection(ngs_plr,snp_lrr,
                         ngs_baf,snp_baf,
                         ngs_plr.pos,snp_lrr.pos,
                         ngs_baf.pos,snp_baf.pos,
                         projname=projname,CN=0,mu=c(-3,0,2),cap=T,visual = 1)
icnv.output = output_list(icnv_res0,sampname_qc,CN=0)
head(icnv.output)
```
The results plot looks are follow. Each row is a sample and each column is a hidden state. The color indicates hidden state Z-score (large positive number prefers amplification, low negative number prefers deletion). Black dots represent amplification detected, while white dots show deletion detected.

![](icnv.demo.png)

We could also plot information in a single individual using function `plotindi`. Example shows below:
```r
icnv_call = icnv_res0[[1]]
plotindi(ngs_plr,snp_lrr,
         ngs_baf,snp_baf,
         ngs_plr.pos,snp_lrr.pos,
         ngs_baf.pos,snp_baf.pos,
         icnv_call,1)
```

### 2.6 Single platform CNV detection using **iCNV** 

At this step, we should alreday have PLR and variants BAF from sequencing OR normalized LRR and BAF from SNP array. Please make sure all the input are in list form. 
Try out with the Demo code and sample dataset in https://github.com/zhouzilu/iCNV/tree/master/demo
NGS only CNV detection using **iCNV** 
```r
library(iCNV)
load('demo_data.rda')
ls()
str(ngs_plr) # List of n vector, each one is the PLR for an exon
str(ngs_plr.pos) # List of n matrix (p x 2), each one is the start and end location for an exon
str(ngs_baf) # List of n vector, each one is the variants BAF from .bam
str(ngs_baf.pos) # List of n vector, each one is the variants BAF position
projname='icnv.demo.ngs'
icnv_res0_ngs=iCNV_detection(ngs_plr=ngs_plr, ngs_baf = ngs_baf, ngs_plr.pos = ngs_plr.pos,ngs_baf.pos = ngs_baf.pos, projname=projname,CN=0,mu=c(-3,0,2),cap=T,visual = 2)
icnv.output = output_list(icnv_res0,sampname_qc,CN=0)
head(icnv.output)
```
![](icnv.demo.ngs.png)

SNP array only CNV detection using **iCNV** 
```r
library(iCNV)
load('demo_data.rda')
ls()
str(snp_lrr) # List of n vector, each one is the normalized LRR for a SNP
str(snp_lrr.pos) # List of n vector, each one is a SNP position
str(snp_baf) # List of n vector, each one is the BAF for a SNP
str(snp_baf.pos) # List of n vector, each one is the SNP BAF position
projname='icnv.demo.snp'
icnv_res0_snp=iCNV_detection(snp_lrr=snp_lrr, snp_baf = snp_baf, snp_lrr.pos = snp_lrr.pos,snp_baf.pos = snp_baf.pos, projname=projname,CN=0,mu=c(-3,0,2),cap=T,visual = 2)
icnv.output = output_list(icnv_res0,sampname_qc,CN=0)
head(icnv.output)
```
![](icnv.demo.snp.png)
